/**
 * JayLink SMS Platform - Enhanced Server Startup
 * Improved error handling and graceful degradation
 */
const path = require('path');
const fs = require('fs');
const http = require('http');
const db = require('./models');
const app = require('./app');
const config = require('./config/config');
const logger = require('./config/logger');
const workers = require('./workers');
const websocket = require('./utils/websocket.util');
const { setupDatabase, getDatabaseHealth, performEmergencyRecovery } = require('./utils/database-setup.util');
const { monitorSystemHealth } = require('./utils/monitoring.util');

/**
 * Application state management
 */
const serverState = {
  server: null,
  databaseReady: false,
  websocketReady: false,
  workersReady: false,
  healthMonitoringActive: false,
  gracefulShutdownInitiated: false,
  startupTime: Date.now(),
  databaseIssues: []
};

/**
 * Enhanced server startup with better error handling
 */
async function startServer() {
  let server;

  try {
    logger.info(`Starting JayLink SMS Platform server (${config.env} environment)`);
    logger.info(`Node.js version: ${process.version}`);
    logger.info(`Platform: ${process.platform} (${process.arch})`);

    // Step 1: Ensure required directories
    await ensureDirectories();

    // Step 2: Initialize email templates
    await initializeTemplates();

    // Step 3: Set up global error handlers
    setupGlobalErrorHandlers();

    // Step 4: Enhanced database setup with better error handling
    const dbSetupResult = await setupDatabaseWithResilience();
    
    // Step 5: Create and configure HTTP server
    server = http.createServer(app);
    serverState.server = server;

    // Step 6: Initialize WebSocket (non-blocking)
    await initializeWebSocketServer(server);

    // Step 7: Initialize subsystems with fallback
    await initializeSubsystemsWithFallback();

    // Step 8: Start health monitoring if enabled
    startHealthMonitoring();

    // Step 9: Start HTTP server
    await startHttpServer(server);

    // Step 10: Setup graceful shutdown
    setupGracefulShutdown(server);

    // Step 11: Log startup success
    logSuccessfulStartup(server, dbSetupResult);

    // Step 12: Schedule post-startup recovery if needed
    if (!dbSetupResult.fullyHealthy) {
      schedulePostStartupRecovery();
    }

    return server;

  } catch (error) {
    logger.error('‚ùå Fatal error during server startup:', error);
    
    // Attempt graceful cleanup
    if (server) {
      try {
        server.close();
      } catch (closeError) {
        logger.error('Error closing server during cleanup:', closeError);
      }
    }
    
    await gracefulExit(1);
  }
}

/**
 * Enhanced database setup with comprehensive error handling
 */
async function setupDatabaseWithResilience() {
  logger.info('üîó Starting resilient database setup');

  const setupResult = {
    success: false,
    fullyHealthy: false,
    canContinue: false,
    issues: [],
    recoveryAttempted: false,
    degradedMode: false
  };

  try {
    // Attempt primary database setup
    logger.info('üîÑ Attempting primary database setup...');
    const primaryResult = await setupDatabase();
    
    setupResult.success = primaryResult.success;
    setupResult.canContinue = primaryResult.shouldContinue;
    setupResult.fullyHealthy = primaryResult.success && primaryResult.fullyHealthy;
    
    if (primaryResult.errors) {
      setupResult.issues.push(...primaryResult.errors);
    }
    if (primaryResult.warnings) {
      setupResult.issues.push(...primaryResult.warnings);
    }

    if (primaryResult.success) {
      logger.info('‚úÖ Primary database setup completed successfully');
      serverState.databaseReady = true;
      return setupResult;
    }

    // Primary setup failed - attempt recovery
    logger.warn('‚ö†Ô∏è  Primary database setup failed, attempting recovery...');
    
    if (config.env === 'production') {
      // In production, be more cautious with recovery
      if (primaryResult.shouldContinue) {
        logger.warn('üîß Production mode: continuing with limited database functionality');
        setupResult.canContinue = true;
        setupResult.degradedMode = true;
        serverState.databaseReady = false;
        serverState.databaseIssues = setupResult.issues;
        return setupResult;
      } else {
        throw new Error('Critical database failure in production - cannot continue');
      }
    }

    // Development mode - attempt emergency recovery
    logger.info('üöë Development mode: attempting emergency database recovery');
    const recoveryResult = await attemptDatabaseRecovery();
    
    setupResult.recoveryAttempted = true;
    
    if (recoveryResult.success) {
      logger.info('‚úÖ Emergency database recovery successful');
      setupResult.success = true;
      setupResult.canContinue = true;
      setupResult.issues.push('Database recovered after initial failure');
      serverState.databaseReady = true;
    } else {
      logger.warn('‚ö†Ô∏è  Emergency recovery failed, continuing with limited functionality');
      setupResult.canContinue = true;
      setupResult.degradedMode = true;
      setupResult.issues.push('Database recovery failed - running in degraded mode');
      serverState.databaseReady = false;
      serverState.databaseIssues = setupResult.issues;
    }

    return setupResult;

  } catch (error) {
    setupResult.issues.push(error.message);
    
    if (config.env === 'production') {
      logger.error('‚ùå Critical database error in production:', error);
      throw error;
    } else {
      logger.warn('‚ö†Ô∏è  Database error in development, attempting to continue:', error);
      setupResult.canContinue = true;
      setupResult.degradedMode = true;
      serverState.databaseReady = false;
      serverState.databaseIssues = setupResult.issues;
      return setupResult;
    }
  }
}

/**
 * Attempt database recovery with comprehensive error handling
 */
async function attemptDatabaseRecovery() {
  try {
    logger.info('üöë Starting comprehensive database recovery process');
    
    const recoveryResult = await performEmergencyRecovery();
    
    if (recoveryResult.success) {
      logger.info('‚úÖ Database recovery completed successfully');
      logger.info('üîß Recovery actions taken:', recoveryResult.actions);
    } else {
      logger.warn('‚ö†Ô∏è  Database recovery completed with issues');
      logger.warn('üîß Recovery actions taken:', recoveryResult.actions);
      logger.warn('‚ùå Recovery errors:', recoveryResult.errors);
    }
    
    return recoveryResult;
  } catch (error) {
    logger.error('‚ùå Database recovery attempt failed:', error);
    return { 
      success: false, 
      actions: [], 
      errors: [error.message] 
    };
  }
}

/**
 * Initialize WebSocket server with enhanced error handling
 */
async function initializeWebSocketServer(server) {
  if (config.websocket?.enabled === false) {
    logger.info('üìã WebSocket support is disabled in configuration');
    return;
  }

  try {
    logger.info('üîå Initializing WebSocket server...');
    
    websocket.initialize(server, {
      path: '/ws',
      pingInterval: config.websocket?.pingInterval || 30000,
      pingTimeout: config.websocket?.pingTimeout || 10000,
      maxPayload: config.websocket?.maxPayload || 100 * 1024
    });
    
    serverState.websocketReady = true;
    logger.info('‚úÖ WebSocket server initialized successfully');
  } catch (wsError) {
    logger.error('‚ùå WebSocket initialization failed:', wsError.message);
    logger.warn('‚ö†Ô∏è  Continuing without WebSocket support');
    serverState.websocketReady = false;
  }
}

/**
 * Initialize subsystems with comprehensive fallback handling
 */
async function initializeSubsystemsWithFallback() {
  logger.info('üîß Initializing subsystems with fallback handling');

  const subsystemResults = {
    workers: false,
    other: false
  };

  // Initialize workers with proper error handling
  if (config.env !== 'test') {
    try {
      logger.info('üîÑ Initializing background workers...');
      
      // Check if database is ready before initializing workers
      if (serverState.databaseReady) {
        workers.initializeWorkers();
        subsystemResults.workers = true;
        serverState.workersReady = true;
        logger.info('‚úÖ Background workers initialized successfully');
      } else {
        logger.warn('‚ö†Ô∏è  Database not ready, initializing workers in limited mode');
        // Initialize workers in limited mode without database-dependent features
        try {
          workers.initializeWorkers({ limitedMode: true });
          subsystemResults.workers = true;
          serverState.workersReady = true;
          logger.info('‚úÖ Background workers initialized in limited mode');
        } catch (limitedError) {
          logger.error('‚ùå Failed to initialize workers even in limited mode:', limitedError.message);
          subsystemResults.workers = false;
        }
      }
    } catch (error) {
      logger.error('‚ùå Worker initialization failed:', error.message);
      subsystemResults.workers = false;
      
      if (config.env === 'production') {
        logger.warn('‚ö†Ô∏è  Production server continuing without workers - some features may be limited');
      } else {
        logger.warn('‚ö†Ô∏è  Development server continuing without workers');
      }
    }
  } else {
    logger.info('üìã Test environment detected, skipping worker initialization');
    subsystemResults.workers = true; // Consider skipped as successful in test
  }

  // Initialize other subsystems here as needed
  // Each should have individual error handling
  
  logger.info('üìä Subsystem initialization completed:', subsystemResults);
}

/**
 * Start health monitoring with enhanced configuration
 */
function startHealthMonitoring() {
  if (!config.monitoring?.enabled) {
    logger.info('üìä Health monitoring is disabled');
    return;
  }

  try {
    logger.info('üìä Starting enhanced system health monitoring');
    
    // Start system monitoring
    monitorSystemHealth(config.monitoring.interval || 60000);
    
    // Start database-specific monitoring
    startDatabaseHealthMonitoring();
    
    serverState.healthMonitoringActive = true;
    logger.info('‚úÖ Health monitoring started successfully');
  } catch (error) {
    logger.error('‚ùå Failed to start health monitoring:', error.message);
    // Continue without monitoring - not critical
  }
}

/**
 * Enhanced database health monitoring
 */
function startDatabaseHealthMonitoring() {
  const dbHealthInterval = config.monitoring?.databaseInterval || 300000; // 5 minutes default

  setInterval(async () => {
    try {
      // Only monitor if database was initially ready
      if (!serverState.databaseReady && serverState.databaseIssues.length === 0) {
        return;
      }

      const healthStatus = await getDatabaseHealth();
      
      if (healthStatus.database?.status === 'error') {
        logger.warn('‚ö†Ô∏è  Database health check detected issues:', {
          status: healthStatus.database?.status,
          error: healthStatus.database?.details?.error
        });

        // If database was previously working, attempt recovery
        if (serverState.databaseReady) {
          logger.info('üîß Database was previously working, attempting automatic recovery');
          const recoveryResult = await attemptDatabaseRecovery();
          
          if (recoveryResult.success) {
            logger.info('‚úÖ Automatic database recovery successful');
            serverState.databaseReady = true;
            serverState.databaseIssues = [];
          } else {
            logger.warn('‚ö†Ô∏è  Automatic database recovery failed');
            serverState.databaseReady = false;
            serverState.databaseIssues = recoveryResult.errors || [];
          }
        }
      } else if (healthStatus.database?.status === 'healthy' && !serverState.databaseReady) {
        logger.info('‚úÖ Database health restored');
        serverState.databaseReady = true;
        serverState.databaseIssues = [];
      }
    } catch (error) {
      logger.debug('Database health monitoring error:', error.message);
    }
  }, dbHealthInterval);
}

/**
 * Schedule post-startup recovery for persistent database issues
 */
function schedulePostStartupRecovery() {
  logger.info('‚è∞ Scheduling post-startup database health recovery');

  // Initial recovery attempt after 30 seconds
  setTimeout(async () => {
    try {
      logger.info('üîç Performing scheduled post-startup database health check');
      
      const healthStatus = await getDatabaseHealth();
      
      if (healthStatus.database?.status === 'error' || healthStatus.models?.status === 'error') {
        logger.warn('‚ö†Ô∏è  Post-startup health check detected database issues');
        
        const recoveryResult = await attemptDatabaseRecovery();
        if (recoveryResult.success) {
          logger.info('‚úÖ Post-startup database recovery successful');
          serverState.databaseReady = true;
          serverState.databaseIssues = [];
        } else {
          logger.warn('‚ö†Ô∏è  Post-startup database recovery failed');
          serverState.databaseIssues = recoveryResult.errors || [];
        }
      } else {
        logger.info('‚úÖ Post-startup database health check passed');
        serverState.databaseReady = true;
        serverState.databaseIssues = [];
      }
    } catch (error) {
      logger.warn('‚ö†Ô∏è  Post-startup health check failed:', error.message);
    }
  }, 30000);

  // Additional periodic checks for the first hour
  const healthCheckInterval = setInterval(async () => {
    try {
      if (serverState.databaseReady) {
        logger.info('‚úÖ Database health fully restored - stopping additional checks');
        clearInterval(healthCheckInterval);
        return;
      }

      const healthStatus = await getDatabaseHealth();
      
      if (healthStatus.database?.status === 'healthy' && 
          healthStatus.models?.status === 'healthy') {
        logger.info('‚úÖ Database health fully restored during periodic check');
        clearInterval(healthCheckInterval);
        serverState.databaseReady = true;
        serverState.databaseIssues = [];
      }
    } catch (error) {
      logger.debug('Scheduled health check error:', error.message);
    }
  }, 300000); // 5 minutes

  // Stop additional checks after 1 hour
  setTimeout(() => {
    clearInterval(healthCheckInterval);
    logger.info('‚è∞ Stopped additional database health checks after 1 hour');
  }, 3600000);
}

/**
 * Create required directories
 */
async function ensureDirectories() {
  logger.info('üìÅ Ensuring required directories exist');

  const directories = [
    'logs',
    'uploads/audio',
    'uploads/csv',
    'uploads/photos',
    'uploads/temp',
    'src/templates/emails',
    'backups/database'
  ];

  for (const dir of directories) {
    try {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        logger.debug(`üìÅ Created directory: ${dir}`);
      }
    } catch (error) {
      logger.warn(`Failed to create directory ${dir}: ${error.message}`);
    }
  }
}

/**
 * Initialize email templates with error handling
 * @returns {Promise<void>}
 */
async function initializeTemplates() {
  logger.info('üìß Initializing email templates');

  try {
    const templatesDir = path.join(__dirname, 'templates');
    if (!fs.existsSync(templatesDir)) {
      logger.warn(`Email templates directory not found: ${templatesDir}`);
      return;
    }

    require('./templates');
    logger.info('‚úÖ Email templates initialized successfully');
  } catch (error) {
    logger.warn(`Email template initialization error: ${error.message}`);
    logger.warn('‚ö†Ô∏è  Continuing without email templates');
  }
}

/**
 * Set up comprehensive global error handlers
 */
function setupGlobalErrorHandlers() {
  logger.info('üõ°Ô∏è  Setting up global error handlers');

  // Handle uncaught exceptions
  process.on('uncaughtException', (err) => {
    logger.error('üö® UNCAUGHT EXCEPTION! Shutting down...', {
      name: err.name,
      message: err.message,
      stack: err.stack?.substring(0, 1000) + '...'
    });

    // Give logging time to complete
    setTimeout(() => {
      process.exit(1);
    }, 1000);
  });

  // Handle unhandled promise rejections
  process.on('unhandledRejection', (reason, promise) => {
    const reasonStr = reason instanceof Error ? reason.message : String(reason);
    logger.error('üö® UNHANDLED REJECTION!', {
      promise: promise.toString().substring(0, 200) + '...',
      reason: reasonStr.substring(0, 200) + '...'
    });

    // In production, exit on unhandled rejections
    if (config.env === 'production') {
      logger.error('üö® Unhandled rejection in production - shutting down');
      setTimeout(() => {
        process.exit(1);
      }, 1000);
    }
  });

  // Handle warnings
  process.on('warning', (warning) => {
    if (warning.name === 'MaxListenersExceededWarning' || 
        warning.name === 'DeprecationWarning') {
      logger.debug(`Node.js Warning: ${warning.name}`, {
        message: warning.message
      });
    } else {
      logger.warn(`Node.js Warning: ${warning.name}`, {
        message: warning.message,
        stack: warning.stack?.substring(0, 500)
      });
    }
  });
}

/**
 * Start HTTP server with enhanced error handling
 */
function startHttpServer(server) {
  return new Promise((resolve, reject) => {
    try {
      const port = normalizePort(config.port || 3000);

      server.listen(port, () => {
        const addr = server.address();
        const bind = typeof addr === 'string' ? `pipe ${addr}` : `port ${addr.port}`;
        logger.info(`üåê HTTP server listening on ${bind}`);
        resolve(server);
      });

      // Enhanced error handling
      server.on('error', (error) => {
        handleServerError(error, port, server, resolve, reject);
      });

      // Handle connections
      server.on('connection', (socket) => {
        socket.setTimeout(config.server?.socketTimeout || 120000);
      });

      // Handle client errors
      server.on('clientError', (err, socket) => {
        logger.debug('Client error:', err.message);
        if (!socket.destroyed) {
          socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
        }
      });

    } catch (error) {
      logger.error('‚ùå Failed to start HTTP server:', error.message);
      reject(error);
    }
  });
}

/**
 * Normalize port value
 */
function normalizePort(val) {
  const port = parseInt(val, 10);
  return isNaN(port) ? val : (port >= 0 ? port : false);
}

/**
 * Enhanced server error handling
 */
function handleServerError(error, port, server, resolve, reject) {
  if (error.syscall !== 'listen') {
    reject(error);
    return;
  }

  const bind = typeof port === 'string' ? `Pipe ${port}` : `Port ${port}`;

  switch (error.code) {
    case 'EACCES':
      logger.error(`‚ùå ${bind} requires elevated privileges`);
      reject(error);
      break;

    case 'EADDRINUSE':
      logger.error(`‚ùå ${bind} is already in use`);
      
      if (config.env !== 'production') {
        logger.info('üîÑ Attempting to use alternative port in development');
        const newPort = typeof port === 'number' ? port + 1 : 3001;
        
        server.removeAllListeners('error');
        server.removeAllListeners('listening');
        
        server.listen(newPort);
        
        server.on('listening', () => {
          const addr = server.address();
          logger.info(`‚úÖ Server listening on alternative port ${addr.port}`);
          resolve(server);
        });
        
        server.on('error', (retryError) => {
          logger.error('‚ùå Failed to bind to alternative port:', retryError.message);
          reject(retryError);
        });
      } else {
        reject(error);
      }
      break;

    default:
      reject(error);
  }
}

/**
 * Set up graceful shutdown handlers
 */
function setupGracefulShutdown(server) {
  const gracefulShutdown = async (signal) => {
    if (serverState.gracefulShutdownInitiated) {
      logger.warn('‚ö†Ô∏è  Graceful shutdown already in progress, forcing exit');
      process.exit(1);
    }

    serverState.gracefulShutdownInitiated = true;
    logger.info(`üîÑ ${signal} received, initiating graceful shutdown...`);

    let exitCode = 0;
    const shutdownSteps = [];

    const forceExitTimeout = setTimeout(() => {
      logger.error('‚è∞ Graceful shutdown timed out after 30 seconds, forcing exit');
      process.exit(1);
    }, 30000);

    try {
      // Close HTTP server
      if (server && serverState.server) {
        await new Promise((resolve, reject) => {
          server.close((err) => {
            if (err) {
              logger.error('‚ùå Error closing HTTP server:', err.message);
              exitCode = 1;
              reject(err);
            } else {
              logger.info('‚úÖ HTTP server closed');
              shutdownSteps.push('HTTP server closed');
              resolve();
            }
          });
        });
      }

      // Close WebSocket server
      if (websocket.isInitialized && websocket.isInitialized() && serverState.websocketReady) {
        try {
          await websocket.close();
          logger.info('‚úÖ WebSocket server closed');
          shutdownSteps.push('WebSocket server closed');
        } catch (wsError) {
          logger.error('‚ùå Error closing WebSocket server:', wsError.message);
          exitCode = 1;
        }
      }

      // Shutdown workers
      if (workers.shutdown && serverState.workersReady) {
        try {
          logger.info('üîÑ Shutting down background workers...');
          await workers.shutdown();
          logger.info('‚úÖ Background workers shut down');
          shutdownSteps.push('Background workers stopped');
        } catch (workerError) {
          logger.error('‚ùå Error shutting down workers:', workerError.message);
          exitCode = 1;
        }
      }

      // Close database connections
      if (db.sequelize && serverState.databaseReady) {
        try {
          logger.info('üîÑ Closing database connections...');
          await db.sequelize.close();
          logger.info('‚úÖ Database connections closed');
          shutdownSteps.push('Database connections closed');
        } catch (dbError) {
          logger.error('‚ùå Error closing database connections:', dbError.message);
          exitCode = 1;
        }
      }

      clearTimeout(forceExitTimeout);

      logger.info('‚úÖ Graceful shutdown completed successfully');
      logger.info('üìã Shutdown steps completed:', shutdownSteps);
      
      await gracefulExit(exitCode);

    } catch (error) {
      logger.error('‚ùå Error during graceful shutdown:', error.message);
      clearTimeout(forceExitTimeout);
      await gracefulExit(1);
    }
  };

  // Handle termination signals
  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
  process.on('SIGINT', () => gracefulShutdown('SIGINT'));

  if (config.env === 'production') {
    process.on('SIGHUP', () => gracefulShutdown('SIGHUP'));
    process.on('SIGQUIT', () => gracefulShutdown('SIGQUIT'));
  }
}

/**
 * Log successful startup with comprehensive status
 */
function logSuccessfulStartup(server, dbSetupResult) {
  const addr = server.address();
  const port = typeof addr === 'string' ? addr : addr.port;
  const startupDuration = Date.now() - serverState.startupTime;

  logger.info('======================================================');
  logger.info('üöÄ JayLink SMS Platform started successfully!');
  logger.info('======================================================');
  
  // Basic info
  logger.info(`üåê Environment: ${config.env}`);
  logger.info(`üîå Server port: ${port}`);
  logger.info(`üåê API URL: ${config.apiUrl || `http://localhost:${port}`}`);
  logger.info(`üñ•Ô∏è  Frontend URL: ${config.frontendUrl || 'http://localhost:8080'}`);
  logger.info(`‚è±Ô∏è  Startup time: ${startupDuration}ms`);
  
  // Service statuses
  logger.info('üìä Service Status:');
  logger.info(`   ‚Ä¢ Database: ${serverState.databaseReady ? '‚úÖ Ready' : '‚ö†Ô∏è  Limited'}`);
  logger.info(`   ‚Ä¢ WebSocket: ${serverState.websocketReady ? '‚úÖ Ready' : '‚ùå Disabled'}`);
  logger.info(`   ‚Ä¢ Workers: ${serverState.workersReady ? '‚úÖ Ready' : '‚ö†Ô∏è  Limited'}`);
  logger.info(`   ‚Ä¢ Health Monitoring: ${serverState.healthMonitoringActive ? '‚úÖ Active' : '‚ùå Disabled'}`);
  
  // Database issues if any
  if (!dbSetupResult.fullyHealthy && dbSetupResult.issues && dbSetupResult.issues.length > 0) {
    logger.info('‚ö†Ô∏è  Database Issues:');
    dbSetupResult.issues.forEach(issue => {
      logger.info(`   ‚Ä¢ ${issue}`);
    });
  }
  
  // System resources
  const memoryUsage = process.memoryUsage();
  logger.info('üß† Memory Usage:');
  logger.info(`   ‚Ä¢ RSS: ${Math.round(memoryUsage.rss / 1024 / 1024)}MB`);
  logger.info(`   ‚Ä¢ Heap Total: ${Math.round(memoryUsage.heapTotal / 1024 / 1024)}MB`);
  logger.info(`   ‚Ä¢ Heap Used: ${Math.round(memoryUsage.heapUsed / 1024 / 1024)}MB`);
  
  // Configuration
  logger.info(`üí∞ Currency: ${config.currency?.name || 'Naira'} (${config.currency?.code || 'NGN'})`);
  
  if (config.env === 'development') {
    logger.info('üîß Development Features:');
    logger.info(`   ‚Ä¢ Auto-recovery: ${config.autoRecovery?.enabled ? 'Enabled' : 'Disabled'}`);
    logger.info('   ‚Ä¢ Hot reload: Available');
  }
  
  logger.info('======================================================');
  
  // Recommendations
  if (!dbSetupResult.fullyHealthy || serverState.databaseIssues.length > 0) {
    logger.warn('üí° Recommendations:');
    logger.warn('   ‚Ä¢ Monitor database health via /api/health endpoint');
    logger.warn('   ‚Ä¢ Check database logs for any ongoing issues');
    if (dbSetupResult.recoveryAttempted) {
      logger.warn('   ‚Ä¢ Database recovery was attempted - verify all features work correctly');
    }
  }
}

/**
 * Enhanced graceful exit
 */
async function gracefulExit(code) {
  if (code === 0) {
    logger.info('üéØ Server shutdown completed successfully');
  } else {
    logger.error(`‚ùå Server shutdown completed with errors (exit code: ${code})`);
  }

  // Allow time for logs to flush
  await new Promise((resolve) => setTimeout(resolve, 1000));
  
  process.exit(code);
}

/**
 * Get current server status
 */
function getServerStatus() {
  return {
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    pid: process.pid,
    version: process.version,
    environment: config.env,
    startupTime: serverState.startupTime,
    services: {
      database: serverState.databaseReady,
      websocket: serverState.websocketReady,
      workers: serverState.workersReady,
      healthMonitoring: serverState.healthMonitoringActive,
    },
    databaseIssues: serverState.databaseIssues,
    gracefulShutdownInitiated: serverState.gracefulShutdownInitiated,
  };
}

/**
 * Perform comprehensive health check
 */
async function performHealthCheck() {
  const healthResult = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    server: getServerStatus(),
    database: null,
    issues: []
  };

  try {
    // Check database health if it was initially ready
    if (serverState.databaseReady) {
      healthResult.database = await getDatabaseHealth();
      
      if (healthResult.database.database?.status === 'error') {
        healthResult.status = 'unhealthy';
        healthResult.issues.push('Database connection failed');
      }
    } else if (serverState.databaseIssues.length > 0) {
      healthResult.status = 'degraded';
      healthResult.issues.push('Database running in degraded mode');
      healthResult.database = { 
        status: 'degraded', 
        issues: serverState.databaseIssues 
      };
    }

    // Check memory usage
    const memUsage = process.memoryUsage();
    const heapUsedPercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;
    
    if (heapUsedPercent > 90) {
      healthResult.status = 'critical';
      healthResult.issues.push('Critical memory usage detected');
    } else if (heapUsedPercent > 75) {
      if (healthResult.status === 'healthy') {
        healthResult.status = 'degraded';
      }
      healthResult.issues.push('High memory usage detected');
    }

  } catch (error) {
    healthResult.status = 'unhealthy';
    healthResult.issues.push(`Health check failed: ${error.message}`);
  }

  return healthResult;
}

// Export functions
module.exports = { 
  startServer,
  getServerStatus,
  performHealthCheck,
  serverState
};

// Start server if this file is run directly
if (require.main === module) {
  startServer().catch((err) => {
    logger.error('‚ùå Failed to start server:', err.message);
    process.exit(1);
  });
}